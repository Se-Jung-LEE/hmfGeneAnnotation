db_names <- str_remove_all(colnames(out),"_score")
max_scores <- do.call(rbind, lapply(1:nrow(out), function(i){
#i = 802
r <- unlist(out[i,], use.names = F)
max_score <- max(r)
if(max_score == 0){ max_score_origin <- 'none' }
else{
max_score_origin <- db_names[which(r == max_score)]
max_score_origin <- paste(max_score_origin, collapse=',')
}
return(data.frame(max_score, max_score_origin))
}))
out <- cbind(out, max_scores)
if(show.raw){
out <- cbind(snpeff.eff, clinvar.eff, enigma.eff, out)
}
}
return(out)
}
calcAdjTumorAd <- function(tumor.ad.ref, tumor.ad.alt, tumor.purity, mode=NULL, show.raw=F){
# tumor.ad.ref = germ$tumor_ad_ref
# tumor.ad.alt = germ$tumor_ad_alt
#
# tumor.ad.ref = som$tumor_ad_ref
# tumor.ad.alt = som$tumor_ad_alt
# tumor.purity = tumor_purity
if(!(mode %in% c('germline','somatic'))){ stop("Please specify mode: 'germline', 'somatic'") }
if(length(tumor.purity) != 1){ stop("tumor.purity must be a single numeric value") }
## Calculate tumor purity adjusted AD
## Do outside of Map loop to take advantage of R's speed with vectors
tumor_dp <- tumor.ad.ref + tumor.ad.alt
normal_purity <- 1 - tumor.purity
normal_dp <- tumor_dp * normal_purity
normal_ad <- normal_dp/2 ## theoretical depth for each allele in normal tissue
adj_tumor_ad_ref <- round(tumor.ad.ref - normal_ad)
if(mode == 'germline'){
adj_tumor_ad_alt <- round(tumor.ad.alt - normal_ad)
} else if(mode == 'somatic'){
## Assumption: somatic variants called by strelka (somatic caller) come with the assumption
## that they belong exclusively to the tumor. Therefore, ALT_DP in somatic variants belongs
## exclusively to the tumor.
adj_tumor_ad_alt <- tumor.ad.alt
}
alt_exists <- adj_tumor_ad_alt >= CUTOFFS$min.adj.tumor.ad.alt
#alt_exists[is.na(alt_exists)] <- F
if(show.raw){
out <- data.frame(tumor.purity, tumor.ad.ref, tumor.ad.alt,
adj_tumor_ad_ref, adj_tumor_ad_alt, alt_exists)
} else {
out <- data.frame(adj_tumor_ad_ref, adj_tumor_ad_alt, alt_exists)
}
## Post-processing
if(mode == 'germline'){
## determine if ref is lost in germline
out$ad_diff_score <- unlist(Map(function(adj_tumor_ad_ref, adj_tumor_ad_alt){
## ad_diff_score = alt/ref
## Taking into account where: ref = 0, ref < 0, and alt <= 0 (to prevent errors)
if( is.na(adj_tumor_ad_ref) || is.na(adj_tumor_ad_alt) || adj_tumor_ad_alt <= 0 ){
ad_diff_score <- 0
} else if(adj_tumor_ad_ref < 0){
## alt/ref makes no sense when ref is negative.
## Set ref to 0: returns Inf or NaN
ad_diff_score <- adj_tumor_ad_alt/0
} else {
ad_diff_score <- adj_tumor_ad_alt/adj_tumor_ad_ref
}
return(ad_diff_score)
}, adj_tumor_ad_ref, adj_tumor_ad_alt, USE.NAMES=F))
out$ref_loss <- out$ad_diff_score >= CUTOFFS$min.germ.ad.diff.score
}
return(out)
}
#--------- Exec ---------#
## Initiate main data structure
mut_profile <- list()
## CNV
if(OPTIONS$verbose){ message('Calculating CNV scores...') }
mut_profile$cnv <- cbind(
input$cnv[,c('ensembl_gene_id','hgnc_symbol')],
calcCnvScores(
input$cnv$min_copy_number, input$cnv$max_copy_number, input$cnv$min_minor_allele_ploidy,
show.raw = T
)
)
## Wrapper function for calcSnvIndelScores() and calcAdjTumorAd()
makeGeneMutProfileGermSom <- function(df, mode){
cbind(
df[,c('gene_id','snpeff_gene','chrom','pos','ref','alt','hgvs_c')],
calcSnvIndelScores(df$snpeff_eff, df$clinvar_sig, df$enigma_sig, show.raw=T),
calcAdjTumorAd(df$tumor_ad_ref, df$tumor_ad_alt, input$purity, mode = mode)
)
}
if(OPTIONS$verbose){ message('Calculating germline mutation scores...') }
mut_profile$germ <- makeGeneMutProfileGermSom(input$germ, mode = 'germline')
if(OPTIONS$verbose){ message('Calculating somatic mutation scores...') }
mut_profile$som <- makeGeneMutProfileGermSom(input$som, mode = 'somatic')
colnames(mut_profile$germ)[1] <- 'ensembl_gene_id'
colnames(mut_profile$som)[1] <- 'ensembl_gene_id'
if(OPTIONS$keep.only.first.eff){
keepFirstEff <- function(df){
#df=mut_profile$germ
df$snpeff.eff <- str_replace_all(df$snpeff.eff,'&.+$','')
return(df)
}
mut_profile$germ <- keepFirstEff(mut_profile$germ)
mut_profile$som <- keepFirstEff(mut_profile$som)
}
## Export raw processed variant data before getting max effect
## This data is needed for identifying VUS's as pathogenic
if(OPTIONS$verbose){ message('Exporting raw mutation profile...') }
if(OPTIONS$export.prelim.data){
write.tsv <- function(...){ write.table(..., sep='\t',quote=F,row.names=F) }
write.tsv(mut_profile$cnv, gzfile(mut_profile_paths$cnv))
write.tsv(mut_profile$germ, gzfile(mut_profile_paths$germ))
write.tsv(mut_profile$som, gzfile(mut_profile_paths$som))
}
} else {
mut_profile <- lapply(mut_profile_paths, function(i){ read.delim(gzfile(i)) })
}
#========= Make table containing 1 variant per type (i.e. cnv, germ, som) =========#
if(OPTIONS$verbose){ message('Determining most pathogenic variant combination per gene...') }
getGeneMaxEff <- function(df, greedy.max.eff=T){
#df=gene_mut_profile$germ
if(nrow(df) == 0){ out <- NA }
else{
gene_ids <- unique(df$ensembl_gene_id)
out <- do.call(rbind, lapply(gene_ids, function(i){
#i="BRE"
df_ss <- df[ df$ensembl_gene_id == i,]
df_ss[which.max(df_ss$max_score),]
if(greedy.max.eff){
out <- df_ss[which.max(df_ss$max_score),]
} else {
max_max_score <- max(df_ss$max_score)
out <- df_ss[df_ss$max_score == max_max_score, ]
}
}))
}
return(out)
}
gene_statuses <- (function(){
l <- list(
cnv=mut_profile$cnv,
germ=getGeneMaxEff(mut_profile$germ, greedy.max.eff=T),
som=getGeneMaxEff(mut_profile$som, greedy.max.eff=T)
)
union_gene_ids <- unlist(lapply(l, function(i){
if( is.data.frame(i) ){ i$ensembl_gene_id }
else { NA }
}), use.names = F)
union_gene_ids <- union_gene_ids[!is.na(union_gene_ids) & nchar(union_gene_ids) != 0] ## rm unknown genes and empty dataframes
#union_gene_ids <- unique(sort(union_gene_ids))
## Cols to select from gene_mut_profile
cols <- list(
cnv = c('min_minor_allele_ploidy','min_copy_number','max_copy_number','cn_diff_in_gene',
'full_gene_loss','loh','cn_break_in_gene'),
germ = c('snpeff.eff','max_score','max_score_origin','adj_tumor_ad_ref',
'adj_tumor_ad_alt','alt_exists','ref_loss'),
som  = c('snpeff.eff','max_score','max_score_origin','adj_tumor_ad_ref',
'adj_tumor_ad_alt','alt_exists')
)
out <- lapply(c('cnv','germ','som'), function(i){
#i='cnv'
#i='som'
#i='germ'
## For df in gene_mut_profile with no variants, create df of NAs for errorless cbind
if(!is.data.frame(l[[i]])){
df <- data.frame(matrix( nrow=length(union_gene_ids), ncol=length(cols[[i]]) ))
colnames(df) <- cols[[i]]
} else {
df <- do.call(rbind, lapply(union_gene_ids, function(j){
#j=union_gene_ids[79]
df_temp <- l[[i]][ l[[i]]$ensembl_gene_id == j, cols[[i]] ]
## If gene id not in mut_profile df, create df of NAs for errorless rbind (inner loop)
if(nrow(df_temp) == 0){ df_temp[1,] <- rep(NA, length(cols[[i]])) }
return(df_temp)
}))
}
return(df)
})
names(out) <- c('','germ','som') ## Empty name for CNV results in no prefix with do.call(cbind, ...)
out <- do.call(cbind, out)
out <- cbind(
ensembl_gene_id = union_gene_ids,
hgnc_symbol = human_genes_enst2ensg[match(union_gene_ids, human_genes_enst2ensg$ensembl_gene_id),'hgnc_symbol'],
out)
})()
## Remove genes not in gene selection
gene_statuses <- gene_statuses[gene_statuses$ensembl_gene_id %in% genes_bed$ensembl_gene_id,]
gene_statuses
subset(gene_statuses, hgnc_symbol=='BRCA1')
SCORING$snpeff
sample_codes <- read.delim(paste0(base_dir,'/manifest/RAD51_for_WGS_codes.txt'))
base_dir <- '/Users/lnguyen/hpc/cog_bioinf/cuppen/project_data/Luan_projects/CHORD/Rotterdam_Patient_Samples/'
sample_codes <- read.delim(paste0(base_dir,'/manifest/RAD51_for_WGS_codes.txt'))
sample_codes
sample_codes <- read.delim(paste0(base_dir,'/manifest/RAD51_for_WGS_codes.txt'))
sample_codes
fastq_paths <- paste0(base_dir,'/manifest/fastq_paths.txt')
system(paste0(
'find ',base_dir,'/downloads/'," -type f -name '*fq.gz' > ",fastq_paths
))
fastq_paths <- read.delim(fastq_paths)
fastq_paths
fastq_paths <- paste0(base_dir,'/manifest/fastq_paths.txt')
system(paste0(
'find ',base_dir,'/downloads/'," -type f -name '*fq.gz' > ",fastq_paths
))
fastq_paths <- read.table(fastq_paths)
fastq_paths
fastq_paths
fastq_paths <- paste0(base_dir,'/manifest/fastq_paths.txt')
system(paste0(
'find ',base_dir,'/downloads/'," -type f -name '*fq.gz' > ",fastq_paths
))
fastq_paths <- read.table(fastq_paths)[,1]
fastq_paths
system(paste0(
'find ',base_dir,'/downloads/'," -type f -name '*fq.gz'"
), intern = T)
fastq_paths <- system(paste0(
'find ',base_dir,'/downloads/'," -type f -name '*fq.gz'"
), intern = T)
grep('A\\d+', fastq_paths, value=T)
library(stringr)
str_extract_all(fastq_paths, 'A\\d+', value=T)
str_extract_all(fastq_paths, 'A\\d+')
str_extract_all(fastq_paths, 'A\\d+/')
fastq_paths
dirname(fastq_paths)
basename(dirname(fastq_paths))
sample_codes
library(stringi)
stri_extract_all(fastq_paths, 'A\\d+')
stri_extract_all(fastq_paths, regex = 'A\\d+')
stri_replace_all(sample_codes$lab_code, '-','')
stri_replace_all(sample_codes$lab_code, fixed='-','')
sample_codes$lab_code <- stri_replace_all(sample_codes$lab_code, fixed='-','')
sample_codes
sample_codes <- read.delim(paste0(base_dir,'/manifest/RAD51_for_WGS_codes.txt'))
sample_codes$lab_code <- stri_replace_all(sample_codes$lab_code, fixed='-','_')
sample_codes
sample_name='CPCT02020306R_CPCT02020306T'
sample_name='CPCT02020306R_CPCT02020306T'
out_dir=paste0('/Users/lnguyen/hpc/cog_bioinf/cuppen/project_data/Luan_projects/CHORD/HMF_update/vcf_subset/',sample_name)
input_paths <- list(
cnv = paste0(out_dir,'/',sample_name,'.purple.gene.cnv'),
germ = paste0(out_dir,'/varsigs_germ.txt.gz'),
som = paste0(out_dir,'/varsigs_som.txt.gz'),
purity = paste0(out_dir,'/',sample_name,'.purple.purity')
)
input <- list(
cnv = read.delim(input_paths$cnv),
germ = read.delim(input_paths$germ),
som = read.delim(input_paths$som),
purity = read.table(input_paths$purity, skip=1)[,1]
)
library(stringr)
options(stringsAsFactors = F)
#========= Paths =========#
#--------- Package ---------#
ROOT_DIR='/hpc/cog_bioinf/cuppen/project_data/Luan_projects/CHORD/scripts_main/hmfGeneAnnotation/'
if(dir.exists('/Users/lnguyen/')){
ROOT_DIR <- paste0('/Users/lnguyen/', ROOT_DIR)
}
## Paths, scoring, cutoffs, and options
source(paste0(ROOT_DIR,'/scripts/annotateGenes/detGeneStatuses_init.R'))
#========= Convert predictors to values =========#
mut_profile_paths <- list(
cnv = paste0(out_dir,'/mut_profile_cnv.txt.gz'),
germ = paste0(out_dir,'/mut_profile_germ.txt.gz'),
som = paste0(out_dir,'/mut_profile_som.txt.gz')
)
#--------- Core functions ---------#
calcCnvScores <- function(
min.copy.number, max.copy.number, min.minor.allele.ploidy,
min.cn.diff.in.gene = CUTOFFS$min.cn.diff.in.gene,
max.max.copy.number = CUTOFFS$max.max.copy.number,
max.min.minor.allele.ploidy = CUTOFFS$max.min.minor.allele.ploidy,
show.raw=F
){
# gene = cnv$Gene
# min.copy.number = cnv$MinCopyNumber
# max.copy.number = cnv$MaxCopyNumber
# min.minor.allele.ploidy = cnv$MinMinorAllelePloidy
## Return empty variable if no CNVs present
if(length(min.copy.number) == 0
& length(max.copy.number) == 0 & length(min.minor.allele.ploidy) == 0){
cnv_scores <- NULL
} else {
cnv_scores <- Map(function(min.copy.number, max.copy.number, min.minor.allele.ploidy){
## Initiate scoring vector
full_gene_loss=F
loh=F
cn_diff_in_gene=0
cn_break_in_gene=F
## 'full gene loss' and 'loh' scores
if(max.copy.number < max.max.copy.number){ full_gene_loss <- T }
if(min.minor.allele.ploidy < max.min.minor.allele.ploidy){ loh <- T }
cn_diff_in_gene <- abs(max.copy.number - min.copy.number) ## max should be > min, but do abs() just in case
if(cn_diff_in_gene >= min.cn.diff.in.gene){ cn_break_in_gene <- T }
return(data.frame(
full_gene_loss, loh, cn_diff_in_gene, cn_break_in_gene
))
}, min.copy.number, max.copy.number, min.minor.allele.ploidy, USE.NAMES=F)
cnv_scores <- do.call(rbind,cnv_scores)
if(show.raw){
cnv_scores <- cbind(
min_copy_number = min.copy.number,
max_copy_number = max.copy.number,
min_minor_allele_ploidy = min.minor.allele.ploidy,
cnv_scores
)
}
#cnv_scores <- cbind(gene=gene,cnv_scores)
}
return(cnv_scores)
}
calcSnvIndelScores <- function(snpeff.eff, clinvar.eff, enigma.eff, show.raw=F){
# snpeff.eff=input$som$snpeff_eff
# clinvar.eff=input$som$clinvar_sig
# enigma.eff=input$som$enigma_sig
# show.raw=T
## Return empty variable if SNVs/indels present
if(
(is.na(snpeff.eff) & is.na(clinvar.eff) & is.na(enigma.eff)) ||
(length(snpeff.eff) == 0 & length(clinvar.eff) == 0 & length(enigma.eff) == 0)
){
if(show.raw){
out <- data.frame(
snpeff.eff=vector(), clinvar.eff=vector(), enigma.eff=vector(),
snpeff_score=vector(), clinvar_score=vector(), enigma_score=vector(),
max_score=vector(), max_score_origin=vector()
)
} else {
out <- data.frame(
snpeff_score=vector(), clinvar_score=vector(), enigma_score=vector(),
max_score=vector(), max_score_origin=vector()
)
}
} else {
## Split into separate lapply loops for easy debugging
if(OPTIONS$verbose){ message('  Getting snpEff scores...') }
snpeff_score <- unlist(lapply(snpeff.eff, function(i){
#i=snpeff.eff[[986]]
if(grepl('&',i)){
i <- str_split(i,'&')[[1]]
score <- max(unlist(lapply(i, function(j){
SCORING$snpeff[SCORING$snpeff$ann == j,'score']
})))
} else {
score <- SCORING$snpeff[SCORING$snpeff$ann == i,'score']
}
## If annotation not found in snpeff table, return 0
if(length(score) == 0 ){ score <- 0 }
return(score)
}))
if(OPTIONS$verbose){ message('  Getting ClinVar scores...') }
clinvar_score <- unlist(lapply(clinvar.eff, function(i){
ifelse(
is.na(i), 0, ## variants not found in db will have NA (from preprocessing with bash scripts)
SCORING$clinvar[SCORING$clinvar$ann == i,'score']
)
}))
if(OPTIONS$verbose){ message('  Getting ENIGMA scores...') }
enigma_score <- unlist(lapply(enigma.eff, function(i){
ifelse(
is.na(i), 0,
SCORING$enigma[SCORING$enigma$ann == i,'score']
)
}))
out <- data.frame(snpeff_score, clinvar_score, enigma_score)
## Calculate max score and which database it came from
db_names <- str_remove_all(colnames(out),"_score")
max_scores <- do.call(rbind, lapply(1:nrow(out), function(i){
#i = 802
r <- unlist(out[i,], use.names = F)
max_score <- max(r)
if(max_score == 0){ max_score_origin <- 'none' }
else{
max_score_origin <- db_names[which(r == max_score)]
max_score_origin <- paste(max_score_origin, collapse=',')
}
return(data.frame(max_score, max_score_origin))
}))
out <- cbind(out, max_scores)
if(show.raw){
out <- cbind(snpeff.eff, clinvar.eff, enigma.eff, out)
}
}
return(out)
}
calcAdjTumorAd <- function(tumor.ad.ref, tumor.ad.alt, tumor.purity, mode=NULL, show.raw=F){
# tumor.ad.ref = germ$tumor_ad_ref
# tumor.ad.alt = germ$tumor_ad_alt
#
# tumor.ad.ref = som$tumor_ad_ref
# tumor.ad.alt = som$tumor_ad_alt
# tumor.purity = tumor_purity
if(!(mode %in% c('germline','somatic'))){ stop("Please specify mode: 'germline', 'somatic'") }
if(length(tumor.purity) != 1){ stop("tumor.purity must be a single numeric value") }
## Calculate tumor purity adjusted AD
## Do outside of Map loop to take advantage of R's speed with vectors
tumor_dp <- tumor.ad.ref + tumor.ad.alt
normal_purity <- 1 - tumor.purity
normal_dp <- tumor_dp * normal_purity
normal_ad <- normal_dp/2 ## theoretical depth for each allele in normal tissue
adj_tumor_ad_ref <- round(tumor.ad.ref - normal_ad)
if(mode == 'germline'){
adj_tumor_ad_alt <- round(tumor.ad.alt - normal_ad)
} else if(mode == 'somatic'){
## Assumption: somatic variants called by strelka (somatic caller) come with the assumption
## that they belong exclusively to the tumor. Therefore, ALT_DP in somatic variants belongs
## exclusively to the tumor.
adj_tumor_ad_alt <- tumor.ad.alt
}
alt_exists <- adj_tumor_ad_alt >= CUTOFFS$min.adj.tumor.ad.alt
#alt_exists[is.na(alt_exists)] <- F
if(show.raw){
out <- data.frame(tumor.purity, tumor.ad.ref, tumor.ad.alt,
adj_tumor_ad_ref, adj_tumor_ad_alt, alt_exists)
} else {
out <- data.frame(adj_tumor_ad_ref, adj_tumor_ad_alt, alt_exists)
}
## Post-processing
if(mode == 'germline'){
## determine if ref is lost in germline
out$ad_diff_score <- unlist(Map(function(adj_tumor_ad_ref, adj_tumor_ad_alt){
## ad_diff_score = alt/ref
## Taking into account where: ref = 0, ref < 0, and alt <= 0 (to prevent errors)
if( is.na(adj_tumor_ad_ref) || is.na(adj_tumor_ad_alt) || adj_tumor_ad_alt <= 0 ){
ad_diff_score <- 0
} else if(adj_tumor_ad_ref < 0){
## alt/ref makes no sense when ref is negative.
## Set ref to 0: returns Inf or NaN
ad_diff_score <- adj_tumor_ad_alt/0
} else {
ad_diff_score <- adj_tumor_ad_alt/adj_tumor_ad_ref
}
return(ad_diff_score)
}, adj_tumor_ad_ref, adj_tumor_ad_alt, USE.NAMES=F))
out$ref_loss <- out$ad_diff_score >= CUTOFFS$min.germ.ad.diff.score
}
return(out)
}
#--------- Exec ---------#
## Initiate main data structure
mut_profile <- list()
## CNV
if(OPTIONS$verbose){ message('Calculating CNV scores...') }
mut_profile$cnv <- cbind(
input$cnv[,c('ensembl_gene_id','hgnc_symbol')],
calcCnvScores(
input$cnv$min_copy_number, input$cnv$max_copy_number, input$cnv$min_minor_allele_ploidy,
show.raw = T
)
)
## Wrapper function for calcSnvIndelScores() and calcAdjTumorAd()
makeGeneMutProfileGermSom <- function(df, mode){
cbind(
df[,c('gene_id','snpeff_gene','chrom','pos','ref','alt','hgvs_c')],
calcSnvIndelScores(df$snpeff_eff, df$clinvar_sig, df$enigma_sig, show.raw=T),
calcAdjTumorAd(df$tumor_ad_ref, df$tumor_ad_alt, input$purity, mode = mode)
)
}
mut_profile$germ <- makeGeneMutProfileGermSom(input$germ, mode = 'germline')
input$germ
## Wrapper function for calcSnvIndelScores() and calcAdjTumorAd()
makeGeneMutProfileGermSom <- function(df, mode){
cbind(
df[,c('ensembl_gene_id','snpeff_gene','chrom','pos','ref','alt','hgvs_c')],
calcSnvIndelScores(df$snpeff_eff, df$clinvar_sig, df$enigma_sig, show.raw=T),
calcAdjTumorAd(df$tumor_ad_ref, df$tumor_ad_alt, input$purity, mode = mode)
)
}
if(OPTIONS$verbose){ message('Calculating germline mutation scores...') }
mut_profile$germ <- makeGeneMutProfileGermSom(input$germ, mode = 'germline')
sample_codes
basename(dirname(fastq_paths))
basename(dirname(fastq_paths))
df <- data.frame(
lab_code=basename(dirname(fastq_paths)),
fastq_path=fastq_paths
)
head(df)
merge(sample_codes,df,by='lab_code')
basename(dirname(fastq_paths)
basename(dirname(fastq_paths))
df
sample_codes
merge(sample_codes,df,by='lab_code')
length(fastq_paths)
df <- data.frame(
lab_code=basename(dirname(fastq_paths)),
fq_path=fastq_paths,
fq_basename=basename(fastq_paths)
)
merge(sample_codes,df,by='lab_code')
df <- data.frame(
lab_code = basename(dirname(fastq_paths)),
fq_basename = basename(fastq_paths),
fq_path = fastq_paths
)
df <- merge(sample_codes,df,by='lab_code')
df
df <- data.frame(
lab_code = basename(dirname(fastq_paths)),
fq_basename = basename(fastq_paths)
#fq_path = fastq_paths
)
df <- merge(sample_codes,df,by='lab_code')
df
