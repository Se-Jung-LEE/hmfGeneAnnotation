is_def <- TRUE
break
}
}
## Return hit_score
## For determining likely cause of HRD when ClinVar/ENIGMA/SnpEff score is <= 4
hit_score <- max(hit_score_list)
if(hit_score < CUTOFFS$hit.score.origin.min.score){
hit_score_origin <- 'none'
} else if(hit_score==SCORING$loh){
hit_score_origin <- 'loh_only'
} else {
hit_score_origin <- names(hit_score_list)[hit_score_list==hit_score]
hit_score_origin <- paste(hit_score_origin,collapse=',')
}
return(data.frame(is_def, def_type, hit_score, hit_score_origin))
}))
gene_statuses <- cbind(gene_statuses,def_status)
## Reorder columns for better readability
sel_cols <- list(
main=c("hgnc_symbol","ensembl_gene_id","is_def","def_type","hit_score","hit_score_origin"),
cnv=c("min_minor_allele_ploidy","min_copy_number","max_copy_number",
"cn_diff_in_gene","full_gene_loss","loh","cn_break_in_gene"),
germ=c("germ.snpeff.eff","germ.max_score","germ.max_score_origin",
"germ.alt_exists","germ.ref_loss","germ.adj_tumor_ad_ref","germ.adj_tumor_ad_alt"),
som=c("som.snpeff.eff","som.max_score","som.max_score_origin",
"som.alt_exists","som.adj_tumor_ad_ref","som.adj_tumor_ad_alt")
)
gene_statuses <- gene_statuses[,unlist(sel_cols)]
gene_statuses
## Rename
colnames(gene_statuses) <- str_replace_all(colnames(gene_statuses),'[.]eff','_eff')
#=========  Make expanded gene statuses table =========#
## Per gene, get all germ/som variants with the hit score as stated in gene_statuses.
constant_cols <- unlist( sel_cols[c('main','cnv')] )
variable_cols <- unique(colnames(mut_profile$germ),colnames(mut_profile$som))
constant_cols
#=========  Make expanded gene statuses table =========#
## Per gene, get all germ/som variants with the hit score as stated in gene_statuses.
constant_cols <- unlist( sel_cols[c('main','cnv')], use.names=F )
variable_cols <- unique(colnames(mut_profile$germ),colnames(mut_profile$som))
variable_cols
constant_cols
final_cols <- unname(c(constant_cols,variable_cols,'mut_origin'))
final_cols
gene_statuses_expanded <- lapply(1:nrow(gene_statuses), function(i){
#i=9
#print(i)
r <- gene_statuses[i,]
r[is.na(r)] <- 'NA' ## NA as a string allows this comparison: NA == NA; TRUE
constant_rows <- r[, constant_cols ]
if(r$hit_score_origin %in% c('full_gene_loss','loh_only','none')){
out <- cbind(constant_rows, mut_origin=NA)
} else {
## Get gene subset of mut_profile$germ or $som
getRelevantMuts <- function(type){
#type='germ'
gmp <- mut_profile[[type]] %>% .[.$gene == r$gene,]
gmp[is.na(gmp)] <- 'NA'
if(nrow(gmp) == 0){ out <- data.frame() }
else {
if(type=='germ'){
out <- gmp %>% .[
.$max_score == r$germ.max_score
& .$ref_loss == r$germ.ref_loss
& .$alt_exists == r$germ.alt_exists
,]
} else if(type=='som'){
out <- gmp %>% .[
.$max_score == r$som.max_score
& .$alt_exists == r$som.alt_exists
,]
}
out$mut_origin <- type
}
return(out)
}
variable_rows_germ <- NULL
variable_rows_som <- NULL
if(grepl('germ',r$hit_score_origin)){ variable_rows_germ <- getRelevantMuts('germ') }
if(grepl('som',r$hit_score_origin)){ variable_rows_som <- getRelevantMuts('som') }
## If only variable_rows_germ or variable_rows_som exists
if( is.null(variable_rows_som) || nrow(variable_rows_som) == 0 ){
variable_rows <- variable_rows_germ
} else if( is.null(variable_rows_germ) || nrow(variable_rows_germ) == 0 ){
variable_rows <- variable_rows_som
## If both exist
} else {
missing_cols <- colnames(variable_rows_germ) %>% .[!(. %in% colnames(variable_rows_som))]
variable_rows_som[,missing_cols] <- NA
variable_rows_som <- variable_rows_som[,colnames(variable_rows_germ)]
variable_rows <- rbind(variable_rows_germ,variable_rows_som)
}
constant_rows <- constant_rows[rep(1,nrow(variable_rows)),]
out <- cbind(constant_rows,variable_rows)
}
if(nrow(out) != 0){
missing_final_cols <- final_cols[!(final_cols %in% colnames(out))]
out[,missing_final_cols] <- 'NA'
out <- out[,final_cols]
} else { ## For when no germ/som variants exist
out <- NULL
}
return(out)
})
gene_statuses_expanded <- do.call(rbind,gene_statuses_expanded)
head(gene_statuses_expanded)
gene_statuses_expanded$ensembl_gene_id.1 <- NULL
colnames(gene_statuses_expanded) <- str_replace_all(colnames(gene_statuses_expanded),'[.]eff','_eff')
gene_statuses_expanded
View(gene_statuses_expanded)
gene_statuses <- (function(){
l <- list(
cnv=mut_profile$cnv,
germ=getGeneMaxEff(mut_profile$germ, greedy.max.eff=T),
som=getGeneMaxEff(mut_profile$som, greedy.max.eff=T)
)
union_gene_ids <- unlist(lapply(l, function(i){
if( is.data.frame(i) ){ i$ensembl_gene_id }
else { NA }
}), use.names = F)
union_gene_ids <- union_gene_ids[!is.na(union_gene_ids) & nchar(union_gene_ids) != 0] ## rm unknown genes and empty dataframes
#union_gene_ids <- unique(sort(union_gene_ids))
## Cols to select from gene_mut_profile
cols <- list(
cnv = c('min_minor_allele_ploidy','min_copy_number','max_copy_number','cn_diff_in_gene',
'full_gene_loss','loh','cn_break_in_gene'),
germ = c('snpeff.eff','max_score','max_score_origin','adj_tumor_ad_ref',
'adj_tumor_ad_alt','alt_exists','ref_loss'),
som  = c('snpeff.eff','max_score','max_score_origin','adj_tumor_ad_ref',
'adj_tumor_ad_alt','alt_exists')
)
out <- lapply(c('cnv','germ','som'), function(i){
#i='cnv'
#i='som'
#i='germ'
## For df in gene_mut_profile with no variants, create df of NAs for errorless cbind
if(!is.data.frame(l[[i]])){
df <- data.frame(matrix( nrow=length(union_gene_ids), ncol=length(cols[[i]]) ))
colnames(df) <- cols[[i]]
} else {
df <- do.call(rbind, lapply(union_gene_ids, function(j){
#j=union_gene_ids[79]
df_temp <- l[[i]][ l[[i]]$ensembl_gene_id == j, cols[[i]] ]
## If gene id not in mut_profile df, create df of NAs for errorless rbind (inner loop)
if(nrow(df_temp) == 0){ df_temp[1,] <- rep(NA, length(cols[[i]])) }
return(df_temp)
}))
}
return(df)
})
names(out) <- c('','germ','som') ## Empty name for CNV results in no prefix with do.call(cbind, ...)
out <- do.call(cbind, out)
out <- cbind(
ensembl_gene_id = union_gene_ids,
hgnc_symbol = human_genes_enst2ensg[match(union_gene_ids, human_genes_enst2ensg$ensembl_gene_id),'hgnc_symbol'],
out)
})()
gene_statuses$ensembl_gene_id
gene_statuses$ensembl_gene_id %in% genes_bed$ensembl_gene_id
#=========  Make expanded gene statuses table =========#
## Per gene, get all germ/som variants with the hit score as stated in gene_statuses.
constant_cols <- unlist( sel_cols[c('main','cnv')], use.names=F )
variable_cols <- unique(colnames(mut_profile$germ),colnames(mut_profile$som))
final_cols <- unname(c(constant_cols,variable_cols,'mut_origin'))
gene_statuses_expanded <- lapply(1:nrow(gene_statuses), function(i){
#i=9
#print(i)
r <- gene_statuses[i,]
r[is.na(r)] <- 'NA' ## NA as a string allows this comparison: NA == NA; TRUE
constant_rows <- r[, constant_cols ]
if(r$hit_score_origin %in% c('full_gene_loss','loh_only','none')){
out <- cbind(constant_rows, mut_origin=NA)
} else {
## Get gene subset of mut_profile$germ or $som
getRelevantMuts <- function(type){
#type='germ'
gmp <- mut_profile[[type]][ mut_profile[[type]]$gene == r$gene, ]
gmp[is.na(gmp)] <- 'NA'
if(nrow(gmp) == 0){ out <- data.frame() }
else {
if(type=='germ'){
out <- gmp[
gmp$max_score == r$germ.max_score
& gmp$ref_loss == r$germ.ref_loss
& gmp$alt_exists == r$germ.alt_exists
,]
} else if(type=='som'){
out <- gmp[
gmp$max_score == r$som.max_score
& gmp$alt_exists == r$som.alt_exists
,]
}
out$mut_origin <- type
}
return(out)
}
variable_rows_germ <- NULL
variable_rows_som <- NULL
if(grepl('germ',r$hit_score_origin)){ variable_rows_germ <- getRelevantMuts('germ') }
if(grepl('som',r$hit_score_origin)){ variable_rows_som <- getRelevantMuts('som') }
## If only variable_rows_germ or variable_rows_som exists
if( is.null(variable_rows_som) || nrow(variable_rows_som) == 0 ){
variable_rows <- variable_rows_germ
} else if( is.null(variable_rows_germ) || nrow(variable_rows_germ) == 0 ){
variable_rows <- variable_rows_som
## If both exist
} else {
missing_cols <- colnames(variable_rows_germ)[!(colnames(variable_rows_germ) %in% colnames(variable_rows_som))]
variable_rows_som[,missing_cols] <- NA
variable_rows_som <- variable_rows_som[,colnames(variable_rows_germ)]
variable_rows <- rbind(variable_rows_germ,variable_rows_som)
}
constant_rows <- constant_rows[rep(1,nrow(variable_rows)),]
out <- cbind(constant_rows,variable_rows)
}
if(nrow(out) != 0){
missing_final_cols <- final_cols[!(final_cols %in% colnames(out))]
out[,missing_final_cols] <- 'NA'
out <- out[,final_cols]
} else { ## For when no germ/som variants exist
out <- NULL
}
return(out)
})
gene_statuses_expanded <- do.call(rbind,gene_statuses_expanded)
gene_statuses_expanded$ensembl_gene_id.1 <- NULL
colnames(gene_statuses_expanded) <- str_replace_all(colnames(gene_statuses_expanded),'[.]eff','_eff')
gene_statuses
#=========  Make expanded gene statuses table =========#
## Per gene, get all germ/som variants with the hit score as stated in gene_statuses.
constant_cols <- unlist( sel_cols[c('main','cnv')], use.names=F )
variable_cols <- unique(colnames(mut_profile$germ),colnames(mut_profile$som))
variable_cols
final_cols <- unname(c(constant_cols,variable_cols,'mut_origin'))
gene_statuses_expanded <- lapply(1:nrow(gene_statuses), function(i){
#i=9
#print(i)
r <- gene_statuses[i,]
r[is.na(r)] <- 'NA' ## NA as a string allows this comparison: NA == NA; TRUE
constant_rows <- r[, constant_cols ]
if(r$hit_score_origin %in% c('full_gene_loss','loh_only','none')){
out <- cbind(constant_rows, mut_origin=NA)
} else {
## Get gene subset of mut_profile$germ or $som
getRelevantMuts <- function(type){
#type='germ'
gmp <- mut_profile[[type]][ mut_profile[[type]]$gene == r$gene, ]
gmp[is.na(gmp)] <- 'NA'
if(nrow(gmp) == 0){ out <- data.frame() }
else {
if(type=='germ'){
out <- gmp[
gmp$max_score == r$germ.max_score
& gmp$ref_loss == r$germ.ref_loss
& gmp$alt_exists == r$germ.alt_exists
,]
} else if(type=='som'){
out <- gmp[
gmp$max_score == r$som.max_score
& gmp$alt_exists == r$som.alt_exists
,]
}
out$mut_origin <- type
}
return(out)
}
variable_rows_germ <- NULL
variable_rows_som <- NULL
if(grepl('germ',r$hit_score_origin)){ variable_rows_germ <- getRelevantMuts('germ') }
if(grepl('som',r$hit_score_origin)){ variable_rows_som <- getRelevantMuts('som') }
## If only variable_rows_germ or variable_rows_som exists
if( is.null(variable_rows_som) || nrow(variable_rows_som) == 0 ){
variable_rows <- variable_rows_germ
} else if( is.null(variable_rows_germ) || nrow(variable_rows_germ) == 0 ){
variable_rows <- variable_rows_som
## If both exist
} else {
missing_cols <- colnames(variable_rows_germ)[!(colnames(variable_rows_germ) %in% colnames(variable_rows_som))]
variable_rows_som[,missing_cols] <- NA
variable_rows_som <- variable_rows_som[,colnames(variable_rows_germ)]
variable_rows <- rbind(variable_rows_germ,variable_rows_som)
}
constant_rows <- constant_rows[rep(1,nrow(variable_rows)),]
out <- cbind(constant_rows,variable_rows)
}
if(nrow(out) != 0){
missing_final_cols <- final_cols[!(final_cols %in% colnames(out))]
out[,missing_final_cols] <- 'NA'
out <- out[,final_cols]
} else { ## For when no germ/som variants exist
out <- NULL
}
return(out)
})
gene_statuses <- (function(){
l <- list(
cnv=mut_profile$cnv,
germ=getGeneMaxEff(mut_profile$germ, greedy.max.eff=T),
som=getGeneMaxEff(mut_profile$som, greedy.max.eff=T)
)
union_gene_ids <- unlist(lapply(l, function(i){
if( is.data.frame(i) ){ i$ensembl_gene_id }
else { NA }
}), use.names = F)
union_gene_ids <- union_gene_ids[!is.na(union_gene_ids) & nchar(union_gene_ids) != 0] ## rm unknown genes and empty dataframes
#union_gene_ids <- unique(sort(union_gene_ids))
## Cols to select from gene_mut_profile
cols <- list(
cnv = c('min_minor_allele_ploidy','min_copy_number','max_copy_number','cn_diff_in_gene',
'full_gene_loss','loh','cn_break_in_gene'),
germ = c('snpeff.eff','max_score','max_score_origin','adj_tumor_ad_ref',
'adj_tumor_ad_alt','alt_exists','ref_loss'),
som  = c('snpeff.eff','max_score','max_score_origin','adj_tumor_ad_ref',
'adj_tumor_ad_alt','alt_exists')
)
out <- lapply(c('cnv','germ','som'), function(i){
#i='cnv'
#i='som'
#i='germ'
## For df in gene_mut_profile with no variants, create df of NAs for errorless cbind
if(!is.data.frame(l[[i]])){
df <- data.frame(matrix( nrow=length(union_gene_ids), ncol=length(cols[[i]]) ))
colnames(df) <- cols[[i]]
} else {
df <- do.call(rbind, lapply(union_gene_ids, function(j){
#j=union_gene_ids[79]
df_temp <- l[[i]][ l[[i]]$ensembl_gene_id == j, cols[[i]] ]
## If gene id not in mut_profile df, create df of NAs for errorless rbind (inner loop)
if(nrow(df_temp) == 0){ df_temp[1,] <- rep(NA, length(cols[[i]])) }
return(df_temp)
}))
}
return(df)
})
names(out) <- c('','germ','som') ## Empty name for CNV results in no prefix with do.call(cbind, ...)
out <- do.call(cbind, out)
out <- cbind(
ensembl_gene_id = union_gene_ids,
hgnc_symbol = human_genes_enst2ensg[match(union_gene_ids, human_genes_enst2ensg$ensembl_gene_id),'hgnc_symbol'],
out)
})()
## Remove genes not in gene selection
gene_statuses <- gene_statuses[gene_statuses$ensembl_gene_id %in% genes_bed$ensembl_gene_id,]
#========= Determine hit score, then deficient genes =========#
if(OPTIONS$verbose){ message('Determining deficient genes...') }
## IS_DEF_MIN_HIT_SCORE is ordered by descending likelihood of causing gene deficiency
IS_DEF_MIN_HIT_SCORE <- c(
'full_gene_loss' = SCORING$full_gene_loss,
## loh & germ.max_score==5 & germ.alt_exists & (germ.ref_loss | cn_break_in_gene)
'loh+germ' =
SCORING$loh + 5 +
SCORING$germ.alt_exists + min(SCORING$germ.ref_loss, SCORING$cn_break_in_gene_loh),
## loh & som.max_score==5 & som.alt_exists
'loh+som' = SCORING$loh + 5 + SCORING$som.alt_exists,
## germ.max_score==5 & som.max_score==5 & germ.alt_exists & (germ.ref_loss | cn_break_in_gene) & som.alt_exists )
'germ+som' = 5 + 5 +
SCORING$germ.alt_exists + min(SCORING$germ.ref_loss, SCORING$cn_break_in_gene_loh) +
SCORING$som.alt_exists
)
calcHitScores <- function(
full_gene_loss=0, loh=0, germ.max_score=0, som.max_score=0,
cn_break_in_gene=0, germ.ref_loss=0, germ.alt_exists=0, som.alt_exists=0,
output=NULL
){
out <- c(
'full_gene_loss' = ifelse(full_gene_loss, SCORING$full_gene_loss, 0),
'loh+germ' =
ifelse(loh, SCORING$loh, 0) +
germ.max_score +
ifelse(germ.alt_exists, SCORING$germ.alt_exists, 0) +
## *** Ensures that germ and som mutations have equal weighting, since 'som.ref_loss' does
## not exist/is not calculated (as it is unreliable), while 'germ.ref_loss' does exist
max(
ifelse(cn_break_in_gene, SCORING$cn_break_in_gene_loh, 0),
ifelse(germ.ref_loss, SCORING$germ.ref_loss, 0)
),
'loh+som' =
ifelse(loh, SCORING$loh, 0) +
som.max_score +
ifelse(som.alt_exists, SCORING$som.alt_exists, 0) +
ifelse(cn_break_in_gene, SCORING$cn_break_in_gene_loh, 0),
'germ+som' =
germ.max_score +
ifelse(germ.alt_exists, SCORING$germ.alt_exists, 0) +
max(
ifelse(cn_break_in_gene, SCORING$cn_break_in_gene_loh, 0),
ifelse(germ.ref_loss, SCORING$germ.ref_loss, 0)
) +
som.max_score +
ifelse(som.alt_exists, SCORING$som.alt_exists, 0)
)
if(is.null(output)){
return(out)
} else {
return(out[output])
}
}
def_status <- do.call(rbind, lapply(1:nrow(gene_statuses), function(i){
#i=3
r <- gene_statuses[i,]
r[is.na(r)] <- 0 ## treat NA's as 0 to avoid errors
hit_score_list <- calcHitScores(
r$full_gene_loss, r$loh, r$germ.max_score, r$som.max_score,
r$cn_break_in_gene, r$germ.ref_loss, r$germ.alt_exists, r$som.alt_exists
)
## Determine is_def
def_type <- 'none'
is_def <- FALSE
for(i in names(hit_score_list)){
if(hit_score_list[[i]] >= IS_DEF_MIN_HIT_SCORE[[i]]){
def_type <- i
is_def <- TRUE
break
}
}
## Return hit_score
## For determining likely cause of HRD when ClinVar/ENIGMA/SnpEff score is <= 4
hit_score <- max(hit_score_list)
if(hit_score < CUTOFFS$hit.score.origin.min.score){
hit_score_origin <- 'none'
} else if(hit_score==SCORING$loh){
hit_score_origin <- 'loh_only'
} else {
hit_score_origin <- names(hit_score_list)[hit_score_list==hit_score]
hit_score_origin <- paste(hit_score_origin,collapse=',')
}
return(data.frame(is_def, def_type, hit_score, hit_score_origin))
}))
gene_statuses <- cbind(gene_statuses,def_status)
## Reorder columns for better readability
sel_cols <- list(
main=c("hgnc_symbol","ensembl_gene_id","is_def","def_type","hit_score","hit_score_origin"),
cnv=c("min_minor_allele_ploidy","min_copy_number","max_copy_number",
"cn_diff_in_gene","full_gene_loss","loh","cn_break_in_gene"),
germ=c("germ.snpeff.eff","germ.max_score","germ.max_score_origin",
"germ.alt_exists","germ.ref_loss","germ.adj_tumor_ad_ref","germ.adj_tumor_ad_alt"),
som=c("som.snpeff.eff","som.max_score","som.max_score_origin",
"som.alt_exists","som.adj_tumor_ad_ref","som.adj_tumor_ad_alt")
)
gene_statuses <- gene_statuses[,unlist(sel_cols)]
## Rename
colnames(gene_statuses) <- str_replace_all(colnames(gene_statuses),'[.]eff','_eff')
#=========  Make expanded gene statuses table =========#
## Per gene, get all germ/som variants with the hit score as stated in gene_statuses.
constant_cols <- unlist( sel_cols[c('main','cnv')], use.names=F )
variable_cols <- unique(colnames(mut_profile$germ),colnames(mut_profile$som))
final_cols <- unname(c(constant_cols,variable_cols,'mut_origin'))
gene_statuses_expanded <- lapply(1:nrow(gene_statuses), function(i){
#i=9
#print(i)
r <- gene_statuses[i,]
r[is.na(r)] <- 'NA' ## NA as a string allows this comparison: NA == NA; TRUE
constant_rows <- r[, constant_cols ]
if(r$hit_score_origin %in% c('full_gene_loss','loh_only','none')){
out <- cbind(constant_rows, mut_origin=NA)
} else {
## Get gene subset of mut_profile$germ or $som
getRelevantMuts <- function(type){
#type='germ'
gmp <- mut_profile[[type]][ mut_profile[[type]]$gene == r$gene, ]
gmp[is.na(gmp)] <- 'NA'
if(nrow(gmp) == 0){ out <- data.frame() }
else {
if(type=='germ'){
out <- gmp[
gmp$max_score == r$germ.max_score
& gmp$ref_loss == r$germ.ref_loss
& gmp$alt_exists == r$germ.alt_exists
,]
} else if(type=='som'){
out <- gmp[
gmp$max_score == r$som.max_score
& gmp$alt_exists == r$som.alt_exists
,]
}
out$mut_origin <- type
}
return(out)
}
variable_rows_germ <- NULL
variable_rows_som <- NULL
if(grepl('germ',r$hit_score_origin)){ variable_rows_germ <- getRelevantMuts('germ') }
if(grepl('som',r$hit_score_origin)){ variable_rows_som <- getRelevantMuts('som') }
## If only variable_rows_germ or variable_rows_som exists
if( is.null(variable_rows_som) || nrow(variable_rows_som) == 0 ){
variable_rows <- variable_rows_germ
} else if( is.null(variable_rows_germ) || nrow(variable_rows_germ) == 0 ){
variable_rows <- variable_rows_som
## If both exist
} else {
missing_cols <- colnames(variable_rows_germ)[!(colnames(variable_rows_germ) %in% colnames(variable_rows_som))]
variable_rows_som[,missing_cols] <- NA
variable_rows_som <- variable_rows_som[,colnames(variable_rows_germ)]
variable_rows <- rbind(variable_rows_germ,variable_rows_som)
}
constant_rows <- constant_rows[rep(1,nrow(variable_rows)),]
out <- cbind(constant_rows,variable_rows)
}
if(nrow(out) != 0){
missing_final_cols <- final_cols[!(final_cols %in% colnames(out))]
out[,missing_final_cols] <- 'NA'
out <- out[,final_cols]
} else { ## For when no germ/som variants exist
out <- NULL
}
return(out)
})
gene_statuses_expanded <- do.call(rbind,gene_statuses_expanded)
gene_statuses_expanded$ensembl_gene_id.1 <- NULL
colnames(gene_statuses_expanded) <- str_replace_all(colnames(gene_statuses_expanded),'[.]eff','_eff')
gene_statuses_expanded
